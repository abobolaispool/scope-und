//code for the Teensy to read the MCP 3008 chip

#include <SPI.h>
//#include <digitalWriteFast.h>  //normal digitalRead/Write is 0.71 us on Teensy 3.0 - test on 4.0

const int CS = 10;                                  //digital pin for chip select
const int buff = 2;                                 //number of samples for the buffer
int Vref = 5;                                       //reference voltage sent to the MCP 3008 by the 5V output on the Teensy
int clk = 3600000;                                  //max clock speed for MCP 3008 chip
int seconds = 1;                                    //the number of seconds that the 500 samples will fill
int sampleFreq = 500/seconds;                       //the sample frequency  
int samplePause = (1/sampleFreq - 24/clk)/0.000001; //the pause time between samples in microseconds

typedef struct
{
  //byte b1; //nothing: XXXXXXXX
  byte b2; //first bits: X X X X X null B9 B8
  byte b3; //last bits: B7 B6 B5 B4 B3 B2 B1
} sampleIn_type;

 
sampleIn_type sampleIn[buff];

double sampleOut[buff];



void setup() {
  // put your setup code here, to run once:
  pinMode(CS, OUTPUT);
  Serial.begin(9600);
  digitalWrite(CS, HIGH); //disable chip select pin so no data is sent before ready
  SPI.begin();
  delay(1000);

}

void loop() {
  // put your main code here, to run repeatedly:

  SPI.beginTransaction(SPISettings(clk, MSBFIRST, SPI_MODE0));

  readSPI(buff, B00000001, B10000000); //B00000001 is the start-bit, B10000000 is single mode and channel 0
  
  SPI.endTransaction();

  for (int j = 0; j < buff; j++) {
    Serial.print("sampleIn.b2: ");
    Serial.println(sampleIn[j].b2);
    Serial.print("samplein.b3: ");
    Serial.println(sampleIn[j].b3);
    Serial.print("sampleOut  ");
    Serial.println(sampleOut[j]);
    Serial.print("j: ");
    Serial.println(j);
    
  }
  delay(1000);

}


void readSPI(int sampleNum, byte startBit, byte modeChannel)  {

  int x, y, z = 0;
 
  for(int i = 0; i < sampleNum; i++){

    //get the digital number from the ADC
    digitalWrite(CS, LOW); //turn on the chip select (CS)
    
    SPI.transfer(startBit); //sending the start bit and receiving garbage
    sampleIn[i].b2 = SPI.transfer(modeChannel); //sending the mode and channel and recieving the two MSB
    sampleIn[i].b3 = SPI.transfer(0); //receiving the last 8 bits

    //process the digital bytes back into the voltage data
    x = sampleIn[i].b2 & B00000011;  //last two bits of this message are the two MSB digital
    y = x * 256;  //convert to higher byte integer number
    z = sampleIn[i].b3 & B11111111;
    sampleOut[i] = (5.0/1024.0)*(y + z);  //add high and low bytes for digital number and convert digital back to analog

    //if (samplePause >= 1) {
    //delayMicroseconds(samplePause);
    //}

    digitalWrite(CS, HIGH); //turn off the chip select (CS)
    
  }

}
